<script>
(function(){
  // Move splash to end of <body> so it's on top in DOM order too
  document.addEventListener("DOMContentLoaded", () => {
    const s = document.getElementById("splash");
    if (s && s.parentNode === document.body) document.body.appendChild(s);
  });

  // --- Random subtext with rotation ---
  const subs = [
    "This might take a few seconds...",
    "Never gonna give you up...",
    "Warming up matrices...",
    "Calibrating color maps...",
    "Sharpening scoring functions...",
    "Bringing the ring to Sauron...",
    "Capturing genomic essence...",
    "Counting available codons...",
    "Trying to generate alien sequences...",
    "404. Error. Motivation not found.",
    "Testing sequence quality...",
    "Perturbing fasta headers...",
    "Coloring nucleotides...",
    "Look at me. I am your new alignment viewer now.",
    "System booting up...",
    "Measuring amino acid properties...",
    "Loading fonts...",
    "Polishing nucleotides...",
    "Shuffling amino acids...",
    "Preparing BLOSUM matrices...",
    "Planning world domination...",
    "Counting gaps (carefully)...",
    "Juggling FASTA files...",
    "Sorting exons from introns...",
    "Preparing the universe...",
    "Assessing chemical properties...",
    "Warming up matplotlib...",
    "Taking a nap...",
    "Calculating the answer to life, the universe, and everything...",
    "42, the answer to life, the universe, and everything.",
    "You are now a MSAexplorer user.",
    "You did it. You are a wizard, Harry.",
    "Holding my breath...",
    "Admiring your beauty...",
    "Life is life. NaNaNaNaNa.",
    "Loading UI..."
  ];
  const subEl = document.querySelector('#splash .sub');
  let rotateId = null;
  if (subEl) {
    let i = Math.floor(Math.random() * subs.length);
    subEl.textContent = subs[i];
    rotateId = setInterval(() => {
      i = (i + 1) % subs.length;
      subEl.textContent = subs[i];
    }, 3000);
  }

  function fadeOut(){
    const el = document.getElementById("splash");
    if (!el) return;
    if (rotateId) { clearInterval(rotateId); rotateId = null; }
    el.style.opacity = 1;
    (function fade(){
      el.style.opacity -= 0.08;
      if (el.style.opacity <= 0) el.style.display = "none";
      else requestAnimationFrame(fade);
    })();
  }

  // Stable idle: only hide after ~1.2s with no busy events
  let busyDepth = 0, hideTimer = null;
  function scheduleHide(delayMs = 1200){
    if (hideTimer) clearTimeout(hideTimer);
    hideTimer = setTimeout(() => { if (busyDepth === 0) fadeOut(); }, delayMs);
  }
  function cancelHide(){ if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; } }

  document.addEventListener("shiny:connected", () => scheduleHide(), { once:true });
  document.addEventListener("shiny:busy", () => { busyDepth++; cancelHide(); });
  document.addEventListener("shiny:idle", () => {
    busyDepth = Math.max(0, busyDepth - 1);
    if (busyDepth === 0) scheduleHide();
  });

  // Optional server-controlled hide
  document.addEventListener("DOMContentLoaded", () => {
    if (window.Shiny && Shiny.addCustomMessageHandler) {
      Shiny.addCustomMessageHandler("splash", msg => {
        if (msg && msg.op === "hide") fadeOut();
      });
    }
  });

  // DOM fallback: when #root first populates, schedule hide (not immediate)
  const root = document.getElementById("root");
  if (root && "MutationObserver" in window) {
    const mo = new MutationObserver(() => {
      if (root.childElementCount > 0) { mo.disconnect(); scheduleHide(1500); }
    });
    mo.observe(root, { childList: true });
  }

  // Safety timeout (in case of errors)
  setTimeout(fadeOut, 30000);
})();
</script>
